package ext.org.apache.poi.hhwpf;

import ext.org.apache.poi.hhwpf.model.DocInfo;
import ext.org.apache.poi.hhwpf.model.FileHeader;
import ext.org.apache.poi.hhwpf.model.datarecord.DataRecordHeader;
import ext.org.apache.poi.hhwpf.model.structure.section.paragraph.Paragraph;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
/*
// sample reference code
    import java.nio.ByteBuffer;
    import java.nio.ByteOrder;

    // To read a little-endian short from a byte array:
    byte[] littleEndianBytes = {0x78, 0x12}; // Example: 0x1278 (little-endian)
    ByteBuffer buffer = ByteBuffer.wrap(littleEndianBytes);
    buffer.order(ByteOrder.LITTLE_ENDIAN); // Set byte order to little-endian
    short value = buffer.getShort(); // Reads the short in little-endian order

    // To write a Java short as little-endian bytes:
    short javaShort = 0x1278; // Example: a Java short
    ByteBuffer writeBuffer = ByteBuffer.allocate(2); // Short is 2 bytes
    writeBuffer.order(ByteOrder.LITTLE_ENDIAN);
    writeBuffer.putShort(javaShort);
    byte[] littleEndianOutput = writeBuffer.array(); // Contains {0x78, 0x12}
 */

/**
 * InputStream 으로 생성, 여러가지 타입으로 읽어 나가기.
 *
 */
public final class StreamReader {
    private static final Logger logger = LoggerFactory.getLogger(StreamReader.class);
    private final InputStream is;
    private int lastReadCount;
    private int cumulativeCount;

    private DataRecordHeader dataRecordHeader = null;
    private long dataRecordDataReadCount;

    private final FileHeader fileHeader;
    private final DocInfo docInfo;

    public FileHeader getFileHeader() {
        return this.fileHeader;
    }

    public StreamReader(InputStream is) {
        this.is = is;
        this.lastReadCount = -1;
        this.cumulativeCount = 0;
        this.dataRecordHeader = null;
        this.dataRecordDataReadCount = -Long.MIN_VALUE;
        this.fileHeader = null;
        this.docInfo = null;
    }
    public StreamReader(InputStream is, FileHeader fileHeader, DocInfo docInfo) {
        this.is = is;
        this.lastReadCount = -1;
        this.cumulativeCount = 0;
        this.dataRecordHeader = null;
        this.dataRecordDataReadCount= -Long.MIN_VALUE;
        this.fileHeader = fileHeader;
        this.docInfo = docInfo;
    }

    public int getLastReadCount() {
        return this.lastReadCount;
    }
    public int getCumulativeCount() {
        return cumulativeCount;
    }

    /**
     * 스트림에서 즉시 읽을 수 있는 바이트 수를 반환하는 InputStream의 available() 을 활용.
     * 최종적으로 스트림의 끝을 확인하고 답을 하는 것은 아니기에 주의 필요.
     * 나중에 수정할 가능성 높음. (분명 Stream이라는 개념으로 출발했지만, 실제로 어떻게 구현되었는지를 모름)
     * @return
     * @throws IOException
     */
    public boolean isAvailable() throws IOException { return this.is.available() > 0; }

    /**
     * 원작자는 correctParaShapeId 라는 명칭 사용함.
     * @param oldParaShapeId
     * @return
     */
    public int getCorrectedParaShapeId(int oldParaShapeId) {
        if (docInfo != null && docInfo.getIdMappings() != null) {
            return oldParaShapeId - docInfo.getIdMappings().getParaShapeCount() + docInfo.getParaShapeList().size();
        } else {
            return oldParaShapeId;
        }
    }

    /**
     * Generated by Google
     * @param initialBytes
     * @param totalLength
     * @return
     */
    private byte[] buildPaddedByteArray(final byte[] initialBytes, final int totalLength) {
        byte[] paddedArray = new byte[totalLength];
        if (initialBytes.length > totalLength) {
            throw new IllegalArgumentException("Initial bytes length exceeds total length.");
        }
        System.arraycopy(initialBytes, 0, paddedArray, 0, initialBytes.length);
        return paddedArray;
    }

    private ByteBuffer buildLittleEndianByteBuffer(final int readCount) throws IOException {
        return ByteBuffer.wrap(this.readBytes(readCount))
                .order(ByteOrder.LITTLE_ENDIAN);
    }

    private ByteBuffer buildLittleEndianByteBuffer(final int readCount, final int requiredCount) throws IOException {
        return ByteBuffer.wrap(this.buildPaddedByteArray(this.readBytes(readCount), requiredCount))
                .order(ByteOrder.LITTLE_ENDIAN);
    }

    private void recalcCount(int n) throws IOException {
        this.lastReadCount = n;
        if(this.lastReadCount>=0) {
            this.cumulativeCount += this.lastReadCount;
            if(this.dataRecordHeader!=null) {
                this.dataRecordDataReadCount += this.lastReadCount;
                if(this.dataRecordHeader.getSize() < this.dataRecordDataReadCount) {
                    this.dataRecordHeader=null;
                    this.dataRecordDataReadCount = -Long.MIN_VALUE;
                } else if(this.dataRecordHeader.getSize() == this.dataRecordDataReadCount) {
                    logger.trace("{} and its data are all read", this.dataRecordHeader);
                }
            }
        } else {
            // throw new IOException("stream is unavailable");
            // 읽을 수 없을 경우, stream.read 에서 이미 exception 발생시킴.
        }
    }

    public byte[] readBytes(final int n) throws IOException {
        byte[] buffer = new byte[n];
        recalcCount( this.is.read(buffer) );
        return buffer;
    }

    public byte readSInt1() throws IOException {
        return readBytes(1)[0];
    }

    public short readUInt1() throws IOException {
        return this.buildLittleEndianByteBuffer(1,2).getShort();
    }

    public short readSInt2() throws IOException {
        return this.buildLittleEndianByteBuffer(2).getShort();
    }

    public int readUInt2() throws IOException {
        return this.buildLittleEndianByteBuffer(2,4).getInt();
    }

    public int readSInt4() throws IOException {
        return this.buildLittleEndianByteBuffer(4).getInt();
    }

    public long readUInt4() throws IOException {
        return this.buildLittleEndianByteBuffer(4,8).getLong();
    }

    public float readFloat() throws IOException {
        return this.buildLittleEndianByteBuffer(4).getFloat();
    }

    public double readDouble() throws IOException {
        return this.buildLittleEndianByteBuffer(8).getDouble();
    }

    /**
     * 한글 문자열을 읽어서 반환한다. 한글 문자열은 2 byte의 문자열 길이가 저장된 부분 뒤에 UTF-16LE 형태의 byte로 된
     * 문자열 부분이 따른다.
     *
     * @return 문자열
     * @throws IOException
     */
    public String readUTF16LEString() throws IOException {
        int len = readUInt2();
        if (len > 0) {
            byte[] arr = readBytes(len * 2);
            return new String(arr, 0, arr.length, StandardCharsets.UTF_16LE);
        } else {
            return null;
        }
    }

    public byte[] readHWPString() throws IOException {
        int len = readUInt2();
        if (len > 0) {
            byte[] arr = readBytes(len * 2);
            return arr;
        } else {
            return null;
        }
    }

    public byte[] readWChar() throws IOException {
        byte[] arr = readBytes(2);
        return arr;
    }

    // 이것도 다시 써야 함.
    // stream 끝과 datarecord 끝까지 읽어야 하는 경우가 다름.
    public byte[] readRestOfStream() throws IOException {
        List<Byte> bytes = new ArrayList<>();
        int data;
        while ((data = this.is.read()) != -1) {
            bytes.add((byte) data);
        }
        byte[] byteArray = new byte[bytes.size()];
        for (int i = 0; i < bytes.size(); i++) {
            byteArray[i] = bytes.get(i);
        }
        this.recalcCount(bytes.size());
        return byteArray;
    }

    public byte[] readRestOfDataRecordData() throws IOException {
        long n = this.dataRecordHeader.getSize() - this.dataRecordDataReadCount;
        return this.readBytes((int) n);
    }

    public DataRecordHeader readDataRecordHeader() throws IOException {
        this.dataRecordHeader = new DataRecordHeader(this);
        this.dataRecordDataReadCount = 0;
        logger.trace("{} has just been read", this.dataRecordHeader);
        return this.dataRecordHeader;
    }

    public DataRecordHeader getCurrentDataRecordHeader() {
        return this.dataRecordHeader;
    }

    public boolean isReadingDataRecordData() {
        if(this.dataRecordHeader==null || this.dataRecordDataReadCount < 0L) {
            this.dataRecordDataReadCount = -Long.MIN_VALUE;
            return false;
        }
        return this.dataRecordHeader.getSize() > this.dataRecordDataReadCount;
    }

    public boolean isEndOfDataRecord() throws IllegalAccessException, IOException {
        if(this.dataRecordHeader!=null) {
            return this.dataRecordHeader.getSize() == this.dataRecordDataReadCount;
        } else if(this.isAvailable()){
            return true;
        }

        throw new IllegalAccessException("No data record for this access");

    }

//    public boolean isReadyToReadDataRecordData() {
//        return this.dataRecordDataReadCount == 0;
//    }

    public long getRemainedDataRecordDataCount() {
        if(this.dataRecordHeader==null || this.dataRecordDataReadCount < 0L) {
//            this.dataRecordDataReadCount = -Long.MIN_VALUE;
            return 0;
        }
        return this.dataRecordHeader.getSize() - this.dataRecordDataReadCount;
    }

}
